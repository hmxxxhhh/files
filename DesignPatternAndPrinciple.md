## 知识基础
- #### 封装
封装（Encapsulation）是面向对象方法的重要原则，就是把对象的属性和操作（或服务）结合为一个独立的整体，并尽可能隐藏对象的内部实现细节。
面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。
- #### 多态
在面向对象语言中，接口的多种不同的实现方式即为多态,允许将子类类型的指针赋值给父类类型的指针。
C++中，实现多态有以下方法：虚函数，抽象类，覆盖，模板（重载和多态无关）。
OC中的多态：不同对象对同一消息的不同响应.子类可以重写父类的方法
- #### 继承
如果一个类A继承自另一个类B，就把这个A称为"B的子类"，而把B称为"A的父类"。继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码。在令子类继承父类的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类的原有属性和方法，使其获得与父类不同的功能。另外，为子类追加新的属性和方法也是常见的做法。
- #### 抽象
在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。
在面向对象方法中，抽象类主要用来进行类型隐藏和充当全局变量的角色。

## 设计原则
1. #### 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
把会变化的部分取出并封装起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分。
1. #### 针对接口编程，而不是针对实现编程。
“针对接口编程”，关键就在多态。利用多态，程序就可以针对超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上。“针对超类型编程”这句话，可以更明确地说成“变量的声明类型应该是超类型，通常是抽象类或者是一个接口，如此是要是具体实现此超类型的类所产生的对象，都可以指定给这个变量。这就意味着，声明类时不用理会以后执行时的真正对象类型！
- **针对实现编程**
`Dog d = new Dog(); d.bark()`
- **针对接口／超类型编程**
`Animal animal = new Dog();animal.makeSound();`
1. #### 多用组合，少用继承
使用组合建立系统具有很大的弹性，不仅可将算法簇封装成类，更可以“在运行时动态地改变行为”，只要组合的行为对象符合正确的接口标准即可。
1. #### 为了对象之间的松耦合设计而努力
当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节，对象之间的相互依赖降到了最低，能让我们建立有弹性的系统。
1. #### 类应该对扩展开放，对修改关闭。
我们的目标是允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。如能实现这样的目标，有什么好处呢？这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。
1. #### 依赖倒置，要依赖抽象，不要依赖具体类。
首先，这个原则听起来很像是“针对接口编程，不针对实现编程”，确实很相似，然而这里更强调“抽象”。这个原则说明了：不能让高层组件依赖低低层组件，而且，不管高层或低层，“两者”都应该依赖于抽象。
- **变量不可以持有具体类的引用**
如果使用new,就会持有具体类的引用，你可以改用工厂来避开这样的做法。
- **不要让类派生自具体类**
如果派生自具体类，你就会依赖具体类，请派生自一个抽象。
- **不要覆盖基类中已实现的方法**
如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享。
1. #### 最少 知识原则：只和你的密友谈话。
这个原则希望我们在设计中，不要让太多的类耦合在一起，免得修改系统中的一部分，会影响到其他部分。如果许多类之间相互依赖，那么这个系统就会变成一个易碎的系统，它需要许多成本维护，也会因为太复杂而不容易被他人了解。
就任何对象而言，在该对象的方法内，我们只应该调用以下范围的方法：
- **该对象本身**
- **被当作方法的参数而传递进来的对象**
- **此方法所创建或实例化的任何对象**
- **对象的任何组件**
不采用这个规则：
```java
	public float getTemp(){
    	Thermometer thermometer = station.getThermometer();
    	return thermometer.getTemperature();
 	}
```
采用这个规则：
```java
	public float getTemp(){
		return station.getTemperature
	}
```
1. #### 好莱坞原则：别调用(打电话给)我们，我们会调用(打电话给)你。
当高层组件依赖底层组件，而底层组件又依赖高层组件，而高层组件又依赖侧边组件，而侧边组件又依赖底层组件时，“依赖腐败”就发生了。在这种情况下，没有人可以轻易的搞懂系统是如何设计的。
在好莱坞原则下，我们允许底层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些底层组件。换句话说，高层组件对待底层组件的方式是“别调用我们，我们会调用你”。
1. #### 一个类应该只有一个引起变化的原因
如果一个类具有两个改变的原因，那么会使得将来该类的变化几率上升，而当它真的改变时，你的设计中同时有两个方面将会受到影响。
- **内聚**
当一个模块或一个类被设计成只支持一组相关的功能时，我们说它具有高内聚；相反，当被设计成支持一组不相关的功能时，我们说它具有低内聚。内聚是一个比单一责任原则更普通的概念，但两者其实关系是很密切的。遵守这个原则的类容易具有高内聚，而且比背负许多责任的低内聚类更容易维护。




## 设计模式
1. #### 策略模式
定义算法簇，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
1. #### 观察者模式
定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
1. #### 装饰者模式
动态地将这人附加到对象上，若要扩展功能，装饰者提供了比继承更具有弹性的替代方案。
1. #### 工厂方法模式
定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。
1. #### 抽象工厂模式
提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
抽象工厂允许客户使用抽象接口来创建一组相关的产品，而不需要知道实际产出的具体是什么产品。这样一来，客户就从具体的产品中被解耦
1. #### 单件模式
确保一个类只有一个实例，并提供一个全局访问点。
1. #### 命令模式
将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命名模式也支持可撤销的操作。
当需要将发出请求的对象和执行请求的对象接偶时候，使用命令模式。
1. #### 适配器模式
将一个接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类合作无间。
1. #### 外观模式 
提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
1. #### 迭代器模式
提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。
1. #### 组合模式
允许你将对象组合成树结构来变现“整体／部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。
组合模式医单一责任设计原则换取透明性，通过让组件的接口同时包含一些管理子节点和叶节点的操作，客户就可以将组合和叶节点一视同仁。也就是说，一个元素究竟是组合还是叶节点，对客户是透明的。
1. #### 状态模式
允许对象在内部状态改变时改变它的行为，对像看起来好像修改了它的类。
1. #### 代理模式
为另一个对象提供一个替身或占位符以控制这个对象的访问。
